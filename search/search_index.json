{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Work In Progress","text":""},{"location":"tutorials/","title":"Travaux Pratiques","text":""},{"location":"tutorials/#liste-des-travaux-pratiques","title":"Liste des travaux pratiques","text":"<ul> <li>TP: RenderDoc: Apprendre \u00e0 utiliser RenderDoc pour analyser une capture de frame.</li> </ul>"},{"location":"tutorials/gl_direct_state_access/","title":"OpenGL - Direct State Access","text":""},{"location":"tutorials/renderdoc/","title":"RenderDoc - Frame Analysis","text":""},{"location":"tutorials/renderdoc/#introduction","title":"Introduction","text":"<p>Dans ce TP, nous allons ouvrir et analyser une capture de jeu \u00e0 l'aide de RenderDoc. La capture a \u00e9t\u00e9 r\u00e9alis\u00e9e dans le template URP 3D Sample  du moteur Unity.</p> <p>Ce template utilise l'Universal Render Pipeline, contenant un bon nombre de features de rendu. Le but ne sera pas de tout analyser en d\u00e9tail, mais d'apprendre \u00e0 se servir de RenderDoc pour naviguer \u00e0 travers la composition de la frame et inspecter les diff\u00e9rentes ressources : textures, buffers, shaders etc...</p> <p>La capture a \u00e9t\u00e9 r\u00e9alis\u00e9 avec l'API OpenGL pour \u00eatre en lien avec le cours de programmation graphique.</p> Rendu de TP <p>Un cours compte-rendu de TP est \u00e0 rendre \u00e0 la fin de celui ci. Il faudra r\u00e9pondre aux questions encadr\u00e9es. Pas besoin de mise en page, de simples phrases suffiront. </p> <p>Info</p> <p>Si vous \u00eates bloqu\u00e9, n'h\u00e9sitez pas \u00e0 solliciter votre encadrant.</p>"},{"location":"tutorials/renderdoc/#premiers-pas","title":"Premiers pas","text":"<p>T\u00e9l\u00e9charger la Capture (157 Mo) </p> <p>Vous pouvez ouvrir la capture via le menu <code>File &gt; Open Capture</code>.</p> <p>Voici le logiciel une fois la capture ouverte :</p> <p></p> <ul> <li>Event Browser Cette fen\u00eatre vous permet de naviguer \u00e0 travers les diff\u00e9rentes phases et appels d'API de la frame captur\u00e9e. Chaque \u00e9v\u00e9nement poss\u00e8de un ID. Certains sont regroup\u00e9s par section.</li> <li>Texture Viewer Cette fen\u00eatre vous permet de visualiser les textures utilis\u00e9es lors d'un \u00e9v\u00e9nement.</li> <li>Pipeline State Cette fen\u00eatre vous permet de visualiser tous les \u00e9tats du pipeline de rendu lors d'un drawcall : ressources attach\u00e9es, shader utilis\u00e9 etc...</li> <li>Mesh Viewer Cette fen\u00eatre vous permet d'inspecter les donn\u00e9es du mesh utilis\u00e9 lors d'un drawcall.</li> <li>Resource Inspector Toutes les ressources cr\u00e9\u00e9es sont r\u00e9pertori\u00e9es ici.</li> </ul> <p>Pour vous facilier la t\u00e2che par la suite, assurez vous que le filtre de l'Event Browser soit <code>$action()</code></p> <p>En ayant le Texture Viewer ouvert, ouvrez la section <code>(EID 511-6810) FrameTime.GPU &gt; UIR.DrawChain</code> et d\u00e9placez vous sur les diff\u00e9rents \u00e9l\u00e9ments. </p> <p>Questions</p> <p>D'apr\u00e8s vous, \u00e0 quoi correspondent les sections <code>GUITexture.Draw</code> ? Quelle section est la plus susceptible de nous int\u00e9resser ?</p> <p>Comme vous l'aurez vite remarqu\u00e9, les captures peuvent contenir beaucoup d'\u00e9v\u00e9nements et de donn\u00e9es qui ne nous int\u00e9ressent pas. Il est donc n\u00e9cessaire de savoir bien naviguer au sein de celles ci.</p>"},{"location":"tutorials/renderdoc/#composition-de-la-frame","title":"Composition de la Frame","text":"<p>Positionnez vous sur la section <code>(EID 1427-6715) ScriptableRenderer.Execute: PC_High_Renderer</code>. En gardant le Texture Viewer ouvert, naviguez entre les diff\u00e9rentes sections.</p> <p>Question</p> <p>D\u00e9crivez bri\u00e8vement les diff\u00e9rentes passes de rendu du renderer. Pour chaque passe, donner le nom des Outputs et votre intuition sur ce qu'elles repr\u00e9sentent. Il est normal que certains outputs soient incompr\u00e9hensibles. Ignorez l'\u00e9v\u00e9nement LightCookies. </p>"},{"location":"tutorials/renderdoc/#draw-object-passes","title":"Draw Object Passes","text":"<p>On peut voir qu'il y a deux passes principales pour dessiner les objets. Une pour les objets opaques et une pour les objets transparents.</p> <p>Une particularit\u00e9 du renderer d'Unity est qu'il ne clear jamais sa target de couleur. Il est donc difficile de visualiser les diff\u00e9rents drawcalls. Pour se faire, utilisez l'overlay <code>Clear Before Pass</code>. Cela permet de forcer le clear de la target avant la passe de rendu.</p> <p></p> <p>En naviguant sur les diff\u00e9rents drawcalls de <code>RenderLoop.DrawSRPBatcher</code>, vous pouvez voir les diff\u00e9rents objets se dessiner petit \u00e0 petit. Vous pouvez aussi utiliser l'overlay <code>Hightlight Drawcall</code> pour mettre en avant l'objet dessin\u00e9.</p> <p>Question</p> <p>Selectionnez l'output de Depth. Utilisez la baguette pour automatiquement ajuster la range de depth.</p> <p> </p> <p>Que pouvez vous observer entre les diff\u00e9rents drawcalls ?</p> <p>Pour valider votre intuition, choisissez un drawcall et ouvrez la fen\u00eatre Pipeline State.</p> <p></p> <p>En haut, vous pouvez apercevoir les diff\u00e9rent stages du pipeline de rendu que vous conaissez bien.</p> <p>Cliquez sur le stage <code>Framebuffer Output (FB)</code>. Le Depth State se trouve en bas.</p> <p>Question</p> <p>D\u00e9crivez le depth state et validez (ou invalidez) votre intuition. En revenant sur les passes de rendu que vous avez observ\u00e9, quel lien pouvez vous faire ?</p>"},{"location":"tutorials/renderdoc/#etude-dun-drawcall","title":"\u00c9tude d'un DrawCall","text":"<p>Choisissez un autre drawcall de la passe <code>DrawOpaqueObjects</code> et ouvrez la fen\u00eatre <code>Pipeline State</code>. Prenez de pr\u00e9f\u00e9rence un drawcall bien visible.</p>"},{"location":"tutorials/renderdoc/#vertex-input","title":"Vertex Input","text":"<p>Question</p> <p>Quels sont les diff\u00e9rents attributs d\u00e9finis par Unity ? Unity utilise-t-il un seul ou plusieurs Buffer pour les vertices ? Ecrivez la structure correspondante au mod\u00e8le de l'objet en C++.</p>"},{"location":"tutorials/renderdoc/#vertex-shader","title":"Vertex Shader","text":"<p>Fouillez dans les informations disponibles. Pour pouvez inspecter les donn\u00e9es des uniforms en cliquant sur la fl\u00e8che dans la section Go.</p> <p>Question</p> <p>O\u00f9 se trouvent les matrices ViewProjection (VP) et ObjectToWorld (M) ? Que pouvez vous d\u00e9duire des noms des Uniform Buffers ?</p>"},{"location":"tutorials/renderdoc/#fragment-shader","title":"Fragment Shader","text":"<p>On peut constater que pas mal de ressources sont utilis\u00e9es par le fragment shader. On y retrouve notamment les ShadowMaps g\u00e9n\u00e9r\u00e9es apr les passes pr\u00e9cedentes.</p> <p>Exercice</p> <p>Ouvre le shader en mode \u00e9dition :</p> <p></p> <p>Le shader est obfusqu\u00e9 mais \u00e9crit en glsl. Modifiez le shader pour que l'objet dessin\u00e9 soit vert (0, 1, 0).</p> <p></p> Exercice (Bonus) <p>Comme pour l'exercice pr\u00e9c\u00e9dent, modifiez le shader pour qu'il affiche les UVs de l'objet. Vous aurez besoin d'aller voir le code du vertex shader.</p> <p></p>"},{"location":"tutorials/renderdoc/#pour-aller-plus-loin","title":"Pour aller plus loin","text":"<p>Nous avons fait le tour de fonctionalit\u00e9s de base.  Pour aller plus loin, vous pouvez vous rendre sur la documentation officielle .</p>"}]}